<h2>什么是递归？</h2>
<p>电影院里，有人问你你坐在第几排，你懒得数，于是你问坐在你前一排的人他坐在第几排，这样在他回答的排数上加1你就可以知道你坐在第几排了。坐在你前一排的人也懒得数，于是就继续去问坐在他前一排的人相同的问题，这样一直下去直到问到坐在第一排的老哥，第一排的老哥当然会告诉你他坐在第一排。于是这个消息会从第一排开始一排一排再传回到你这里，当然每个接受到这个消息的人会在这个结果上加1再把结果传给后排的人，于是你就可以得到你在第几排啦~~</p>

<h2>相关文章</h2>
递归 https://leetcode-cn.com/circle/article/koSrVI/  <br>
回溯 https://segmentfault.com/a/1190000006121957

<h2>时间复杂度（master公式）</h2>
T(N) = a*T(N/b) + O(N^d)

a 出现几次递归调用 <br>
b 本次切分的规模是原问题的几分之几 <br>
d 常数项操作时间 <br>

1) log(b,a) > d -> 复杂度为O(N^log(b,a)) 
2) log(b,a) = d -> 复杂度为O(N^d * logN) 
3) log(b,a) < d -> 复杂度为O(N^d)

<h2>一些技巧</h2>
<ul>
    <li><strong>探测递推公式:</strong>&nbsp;&nbsp; 尝试正推和反推并对过程进行抽象归纳，正推即找到问题最基本的解然后推出第二层第三层解，是否可以通过当前层的解拼出下一层的解（如斐波那契数列）。反推则是把问题先想象成最终解的前一步，此时需要考虑的是最终解和当前层解的依赖关系。</li>
    <li><strong>找到递归出口:</strong>&nbsp;&nbsp;递归出口取决于你定义的函数原含义（参数变化的意义和返回值的意义）。退出条件可能是达到基础问题f(1)的解，也可能是参数波动到了不合法的边界，还可能是达到子问题的最优选择策略</li>
    <li><strong>关于优化:</strong>&nbsp;&nbsp;1.分析是否有重复计算问题。常见策略可以根据题意使用记忆化和减枝的办法避免。2.尽量采用尾递归来减少对栈及中间变量的状态保存的额外空间开销</li>
    <li><strong>局部变量&全局变量:</strong> 递归函数中局部变量常见的含义（1.记录当前层参数的状态（递归返回回来时需要用到）。2.记录并返回当前层不同尝试下的局部结果或过程）全局变量常见用于回溯解法中求一共有多少种,最值等场景</li>
</ul>

<h2>常见衍生思想</h2>
<ul>
    <li><strong>回溯:</strong>&nbsp;&nbsp; 好比从山脚下找一条爬上山顶的路,起初有好几条道可走,当选择一条道走到某处时,又有几条岔道可供选择,只能选择其中一条道往前走,若能这样子顺利爬上山顶则罢了,否则走到一条绝路上时或者这条路上有一坨屎,我们只好返回到最近的一个路口,重新选择另一条没走过的道往前走。如果该路口的所有路都走不通,只得从该路口继续回返。照此规则走下去,要么找到一条到达山顶的路,要么最终试过所有可能的道,无法到达山顶。本质上是一种穷举，一般回溯的问题有三种（1.有没有解。2.求所有解(个数或信息)。3.求最优解）可以抽象为一棵树，我们的目标可以是找这个树有没有good leaf，也可以是问有多少个good leaf，也可以是找这些good leaf都在哪，也可以问哪个good leaf最好，分别对应上面所说回溯的问题分类。</li>
    <li><strong>二分法:</strong>&nbsp;&nbsp; 常用于排序算法中（如快排，归并）</li>
    <li><strong>Y or N:</strong>&nbsp;&nbsp; 背包问题 字符串子序列等问题 </li>
    <li><strong>卡特兰数:</strong>&nbsp;&nbsp;生成二叉树 中心点动态移动 不同的中心点和左右两边产生的关联</li>
    <li><strong>状态抵消:</strong>&nbsp;&nbsp;欧拉信箱问题 如果一个问题存在两个status（收信和寄信） 则不通人之间的问题可以化简抵消</li>
    <li><strong>还原现场:</strong>&nbsp;&nbsp; 当修改了引用类型参数并且传递到了下层时候 不要忘记当调用返回到本层时候还原数据模型（常见于回溯中）</li>
</ul>



