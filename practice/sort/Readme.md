<h2>时间复杂度</h2>
<p>时间复杂度是衡量算法好坏的重要指标之一。时间复杂度反映的是不确定性样本量的增长对于算法操作所需时间的影响程度，与算法操作是否涉及到样本量以及涉及了几次直接相关，如遍历数组时时间复杂度为数组长度n（对应时间复杂度为O(n)），而对数据的元操作（如加减乘除与或非等）、逻辑操作（如if判断）等都属于常数时间内的操作（对应时间复杂度O(1)）。
</p>
<p>在化简某算法时间复杂度表达式时需遵循以下规则：</p>

<ul>
    <li>对于同一样本量，可省去低阶次数项，仅保留高阶次数项，如O(n^2)+O(n)可化简为O(n^2)，O(n)+O(1)可化简为O(n)</li>
    <li>可省去样本量前的常量系数，如O(2n)可化简为O(n)，O(8)可化简为O(1)</li>
    <li>对于不同的不确定性样本量，不能按照上述两个规则进行化简，要根据实际样本量的大小分析表达式增量。如O(logm)+O(n^2)不能化简为O(n^2)或O(logm)。而要视m、n两者之间的差距来化简，比如m > n时可以化简为O(logm)，因为表达式增量是由样本量决定的</li>
</ul>

<h2>额外空间复杂度</h2>
<p>算法额外空间复杂度指的是对于输入样本，经过算法操作需要的额外空间。比如使用冒泡排序对一个数组排序，期间只需要一个临时变量temp，那么该算法的额外空间复杂度为O(1)。又如归并排序，在排序过程中需要创建一个与样本数组相同大小的辅助数组，尽管在排序过后该数组被销毁，但该算法的额外空间复杂度为O(n)。</p>


<h2>冒泡排序</h2>
<p>冒泡排序的核心是从头遍历序列。以升序排列为例：将第一个元素和第二个元素比较，若前者大于后者，则交换两者的位置，再将第二个元素与第三个元素比较，若前者大于后者则交换两者位置，以此类推直到倒数第二个元素与最后一个元素比较，若前者大于后者，则交换两者位置。这样一轮比较下来将会把序列中最大的元素移至序列末尾，这样就安排好了最大数的位置，接下来只需对剩下的（n-1）个元素，重复上述操作即可。</p>

![](https://user-gold-cdn.xitu.io/2019/2/19/169045adb8cae9fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

<h2>选择排序</h2>
<p>以升序排序为例：找到最小数的下标minIndex，将其与第一个数交换，接着对子序列（1-n）重复该操作，直到子序列只含一个元素为止。</p>

![](https://user-gold-cdn.xitu.io/2019/2/19/169045adc21bc014?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

<h2>插入排序</h2>
<p>插入排序的过程可以联想到打扑克时揭一张牌然后将其到手中有序纸牌的合适位置上。比如我现在手上的牌是7、8、9、J、Q、K，这时揭了一张10，我需要将其依次与K、Q、J、9、8、7比较，当比到9时发现大于9，于是将其插入到9之后。对于一个无序序列，可以将其当做一摞待揭的牌，首先将首元素揭起来，因为揭之前手上无牌，因此此次揭牌无需比较，此后每揭一次牌都需要进行上述的插牌过程，当揭完之后，手上的握牌顺序就对应着该序列的有序形式。</p>

![](https://user-gold-cdn.xitu.io/2019/2/19/169045adc2eba88c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

<h2>归并排序</h2>
<p>归并排序的核心思想是先让序列的左半部分有序、再让序列的右半部分有序，最后从两个子序列（左右两半）从头开始逐次比较，往辅助序列中填较小的数</p>

![](https://user-gold-cdn.xitu.io/2019/2/19/169045adc484ee3e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

<h2>快速排序</h2>
<p>在容器中按照某种特定规则(partition)取一个元素（如：取下表为0的元素） 把它看做中轴(pivot) 以中轴为中心，把小于中轴的元素放在左边，大于的放在右边。
常见的partition办法有挖坑填数 和 🇳🇱</p>

<h2>堆排序</h2>
<p>堆结构就是将一颗完全二叉树映射到数组中的一种存储方式,当堆的每一颗子树（包括树本身）的最大值就是其结点时称为大根堆；相反，当堆的每一颗子树的最小值就是其根结点时称为小根堆。其中大根堆的应用较为广泛，是一种很重要的数据结构。</p>

![](https://user-gold-cdn.xitu.io/2019/2/19/169045adc8a101c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
![](https://user-gold-cdn.xitu.io/2019/2/19/169045ae11912cf6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
<p>大根堆最重要的两个操作就是heapInsert和heapify，前者是当一个元素加入到大根堆时应该自底向上与其父结点比较，若大于父结点则交换；后者是当堆中某个结点的数值发生变化时，应不断向下与其孩子结点中的最大值比较，若小于则交换</p>

![](https://user-gold-cdn.xitu.io/2019/2/19/169045ae138de589?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

<h2>排序算法的稳定性</h2>
<p>排序算法的稳定性指的是排序前后是否维持值相同的元素在序列中的相对次序。如序列271532，在排序过程中如果能维持第一次出现的2在第二次出现的2的前面，那么该排序算法能够保证稳定性。</p>
<ul>
    <li>冒泡排序。可以保证稳定性，只需在比较相邻两个数时只在后一个数比前一个数大的情况下才交换位置即可。</li>
    <li>选择排序。无法保证稳定性，比如序列926532，在第一轮maxIndex的选择出来之后（maxIndex=0），第二次出现的2（尾元素）将与9交换位置，那么两个2的相对次序就发生了变化，而这个交换是否会影响稳定性在我们coding的时候是不可预测的。</li>
    <li>插入排序。可以保证稳定性，每次插入一个数到有序序列中时，遇到比它大的就替换，否则不替换。这样的话，值相同的元素，后面插入的就总在前面插入的后面了。</li>
    <li>归并排序。可以保证稳定性，在左右两半子序列排好序后的merge过程中，比较大小时如果相等，那么优先插入左子序列中的数。</li>
    <li>快排。不能保证稳定性，因为partition的过程会将比num小的与small区域的右一个数交换位置，将比num大的与great区域的左一个数交换位置，而small、great分居序列两侧，很容易打乱值相同元素的相对次序。</li>
    <li>堆排序。不能保证稳定性。二叉树如果交换位置的结点是相邻层次的可以保证稳定性，但堆排序中弹出堆顶元素后的heapify交换的是第一层的结点和最后一层的结点。</li>
</ul>